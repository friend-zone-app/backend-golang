package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"parties-app/backend/authentication"
	"parties-app/backend/database"
	"parties-app/backend/directives"
	"parties-app/backend/errorHandler"
	"parties-app/backend/graph/customTypes"
	"parties-app/backend/graph/generated"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, updateUser customTypes.UpdateUserArgs) (bool, error) {
	objectID, err := primitive.ObjectIDFromHex(updateUser.Query)
	if err != nil {
		errorHandler.HandleError(ctx, 401, "Invalid Query user's ID.")
		return false, err
	}

	err = database.UpdateUser(objectID, updateUser)
	if err != nil {
		errorHandler.HandleError(ctx, 500, "Unable to update user.")
		return false, err
	}

	return true, nil
}

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, createUser customTypes.CreateUserArgs) (*customTypes.User, error) {
	panic(fmt.Errorf("not implemented: Signup - signup"))
}

// UpdateDate is the resolver for the updateDate field.
func (r *mutationResolver) UpdateDate(ctx context.Context, updateDate customTypes.UpdateDateInput) (bool, error) {
	panic(fmt.Errorf("not implemented: UpdateDate - updateDate"))
}

// RemoveDate is the resolver for the removeDate field.
func (r *mutationResolver) RemoveDate(ctx context.Context, removeDate customTypes.RemoveDateInput) (bool, error) {
	panic(fmt.Errorf("not implemented: RemoveDate - removeDate"))
}

// CreateDate is the resolver for the createDate field.
func (r *mutationResolver) CreateDate(ctx context.Context, createDate customTypes.CreateDateInput) (bool, error) {
	panic(fmt.Errorf("not implemented: CreateDate - createDate"))
}

// GetUserByID is the resolver for the getUserById field.
func (r *queryResolver) GetUserByID(ctx context.Context, id primitive.ObjectID) (*customTypes.SensoredUser, error) {
	panic(fmt.Errorf("not implemented: GetUserByID - getUserById"))
}

// GetUserByName is the resolver for the getUserByName field.
func (r *queryResolver) GetUserByName(ctx context.Context, username string) (*customTypes.SensoredUser, error) {
	panic(fmt.Errorf("not implemented: GetUserByName - getUserByName"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*customTypes.User, error) {
	userId := directives.ForContext(ctx)
	if len(userId) < 5 {
		errorHandler.HandleError(ctx, http.StatusNotAcceptable, "The authorization header is not found! (ForContext)")
		return nil, errors.New("the authorization header is not found (ForContext)")
	}
	id, err := authentication.ConvertUserIDStringToObjectID(userId)
	if err != nil {
		errorHandler.HandleError(ctx, http.StatusNotAcceptable, "The user id provided is invalid! (ConvertUserIDStringToObjectID)")
		return nil, err
	}
	user, found, err := database.GetUserByID(*id)
	if !found && err != nil {
		errorHandler.HandleError(ctx, http.StatusInternalServerError, "Failed to fetch user (GetUserByID)")
		fmt.Println(id)
		return nil, err
	} else if !found && err == nil {
		errorHandler.HandleError(ctx, http.StatusNotFound, "User with that ID doesn't exist (GetUserByID)")
		fmt.Println(id)
		return nil, err
	}

	return user, nil
}

// RequestLogin is the resolver for the requestLogin field.
func (r *queryResolver) RequestLogin(ctx context.Context, email string) (bool, error) {
	err := authentication.LogInRequest(email)
	if err != nil {
		log.Fatalln(err)
		errorHandler.HandleError(ctx, 500, "Unable to send email address")
		return false, err
	}

	return true, nil
}

// ValidateOtp is the resolver for the validateOtp field.
func (r *queryResolver) ValidateOtp(ctx context.Context, code string, email string, username string) (*customTypes.UserRes, error) {
	err := authentication.VeritifyEmail(code, email)
	if err != nil {
		errMessage := err.Error()
		if errMessage == "0" {
			errorHandler.HandleError(ctx, http.StatusNotFound, "The email provided hasn't been request a email verification! (VerifyEmail)")
			return nil, err
		} else {
			errorHandler.HandleError(ctx, http.StatusNotAcceptable, "The verification code provided is expired or incorrect! Please request a new one. (VertifyEmail)")
			return nil, err
		}
	}

	newUserID := primitive.NewObjectID()
	user, found, err := database.GetUserByEmail(email)
	if !found && err != nil {
		errorHandler.HandleError(ctx, http.StatusInternalServerError, "Failed to fetch user with that email address! (GetUserByEmail)")
		return nil, err
	} else if !found && err == nil {
		uniqueUsername, err := database.CreateARandomUsername(username)
		if err != nil {
			errorHandler.HandleError(ctx, http.StatusInternalServerError, "Failed to fetch usernames! (CreateARandomUsername)")
			return nil, err
		}

		user = &customTypes.User{
			ID:           newUserID,
			DisplayName:  username,
			Username:     uniqueUsername,
			Email:        email,
			CreatedAt:    time.Now(),
			Salt:         authentication.GenerateRandomSalt(10),
			LastSignedIn: time.Now(),
		}

		ok, err := database.CreateUser(*user)
		if err != nil || !ok {
			errorHandler.HandleError(ctx, http.StatusInternalServerError, "Failed to create new user! (CreateUser)")
			return nil, err
		}
	}

	tokens, err := authentication.Sign(newUserID)
	if err != nil {
		errorHandler.HandleError(ctx, http.StatusInternalServerError, "Failed to sign a new token (Sign)")
		return nil, err
	}

	respond := customTypes.UserRes{
		User:  user,
		Token: tokens,
	}

	return &respond, nil
}

// Logout is the resolver for the logout field.
func (r *queryResolver) Logout(ctx context.Context) (bool, error) {
	panic(fmt.Errorf("not implemented: Logout - logout"))
}

// RefreshToken is the resolver for the refreshToken field.
func (r *queryResolver) RefreshToken(ctx context.Context) (*customTypes.Tokens, error) {
	panic(fmt.Errorf("not implemented: RefreshToken - refreshToken"))
}

// GetEvents is the resolver for the getEvents field.
func (r *queryResolver) GetEvents(ctx context.Context, username string, duration *string) ([]*customTypes.Event, error) {
	panic(fmt.Errorf("not implemented: GetEvents - getEvents"))
}

// GetEventByID is the resolver for the getEventById field.
func (r *queryResolver) GetEventByID(ctx context.Context, username string, id string) (*customTypes.Event, error) {
	panic(fmt.Errorf("not implemented: GetEventByID - getEventById"))
}

// GetLocationData is the resolver for the getLocationData field.
func (r *queryResolver) GetLocationData(ctx context.Context, lat string, long string) (*customTypes.Location, error) {
	panic(fmt.Errorf("not implemented: GetLocationData - getLocationData"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
